import { Cards, Card } from 'nextra/components'

# Historical Parts API Documentation

## Base URL
`https://historical-parts.onrender.com/api/products`

## Authentication
No authentication required.

## Endpoints

### Pickup only
- **Description**: Retrieves products available for pickup only.
- **Method**: GET
- **Endpoint**: `/api/products?filters[ShippingOptions][$eq]=Pick up yourself`

### Two conditions
- **Description**: Retrieves product sin good or okay condition.
- **Method**: GET
- **Endpoint**: `/api/products?filters[$or][0][Condition][$eq]=Good condition&filters[$or][1][Condition][$eq]=Okay condition?populate=*`

### Materials
- **Description**: Retrieves products made of steel or aluminum priced below 600 and available for pickup in Stockholm.
- **Method**: GET
- **Endpoint**: `/api/products?filters[Price][$lt]=600&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself&filters[$or][0][Material][$eq]=Steel&filters[$or][1][Material][$eq]=Aluminum`

### Less than 600 wood Stockholm and pickup only
- **Description**: Retrieves products made of wood priced below 600 located in Stockholm and available for pickup only.
- **Method**: GET
- **Endpoint**: `/api/products?filters[Price][$lt]=901&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself&filters[$or][0][Material][$eq]=Wood`

### Two styles
- **Description**: Retrieves products from the C. 1880s New Renaissance or E. 1900-1910s Art Nouveau styles.
- **Method**: GET
- **Endpoint**: `/api/products?filters[$or][0][Era][$eq]=C. 1880s New Renaissance&filters[$or][1][Era][$eq]=E. 1900-1910s Art Nouveau`

### Price Less than 500 three styles
- **Description**: Retrieves products priced below 500 from three different styles: C. 1880s New Renaissance, E. 1900-1910s Art Nouveau, and I. 1940s-1950s Modernism Folkhem Architecture.
- **Method**: GET
- **Endpoint**: `/api/products?filters[Price][$lt]=500&filters[$or][0][Era][$eq]=C. 1880s New Renaissance&filters[$or][1][Era][$eq]=E. 1900-1910s Art Nouveau&filters[$or][2][Era][$eq]=I. 1940s-1950s Modernism Folkhem Architecture`

### Price less than 300 in Stockholm Pickup only
- **Description**: Retrieves products priced below 300 located in Stockholm and available for pickup only.
- **Method**: GET
- **Endpoint**: `/api/products?filters[Price][$lt]=300&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself`

### Price less than 500
- **Description**: Retrieves products priced below 500.
- **Method**: GET
- **Endpoint**: `/api/products?filters[Price][$lt]=500`

### Pickup and Stockholm
- **Description**: Retrieves products available for pickup in Stockholm.
- **Method**: GET
- **Endpoint**: `/api/products?filters[ShippingOptions][$eq]=Pick up yourself&filters[Location][$eq]=Stockholm`

### Dropoff and Linköping
- **Description**: Retrieves products available for dropoff in Linköping.
- **Method**: GET
- **Endpoint**: `/api/products?filters[ShippingOptions][$eq]=Get a shipping price&filters[Location][$eq]=Linköping`

### Pickup and Stockholm and less than 500
- **Description**: Retrieves products priced below 500 available for pickup in Stockholm.
- **Method**: GET
- **Endpoint**: `/api/products?filters[ShippingOptions][$eq]=Pick up yourself&filters[Location][$eq]=Stockholm&filters[Price][$lt]=500`

## Headers
- **User-Agent**: `insomnia/8.6.1`


### Fetch
Here is how you might use React hooks to fetch data from our API, using Strapi as the backend.
In our project, we've implemented two essential utilities, `useFetch` and `makeRequest`, to streamline the process of fetching data from our Strapi-powered API. Below is an in-depth look at each utility, demonstrating how they are constructed and how they function within our React application.

useFetch is a custom React hook that we've developed to simplify the process of fetching data from the API, handling loading states, errors, and the response data. This hook is designed to be reusable across different components within our application, promoting code reusability and cleaner component structures.

```javascript
import { useEffect, useState } from "react";
import { makeRequest } from "../makeRequest";

const useFetch = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);
  const [meta, setMeta] = useState(null);
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const res = await makeRequest.get(url);
        setData(res.data.data);
        setMeta(res.data.meta);
      } catch (err) {
        setError(true);
      }
      setLoading(false);
    };
    fetchData();
  }, [url]);

  return { data, loading, error, meta };
};

export default useFetch;

```

### makeRequest.js
The `makeRequest` utility is a configured instance of `axios`, a popular HTTP client for making requests to APIs. We've set it up to dynamically choose the base URL depending on whether the environment is in production or development mode. This setup ensures that API requests are directed to the correct server without manual changes to the codebase when moving from development to production.

```javascript
import axios from 'axios';

// Environment-specific API URLs
const apiUrl = import.meta.env.PROD
  ? import.meta.env.VITE_API_URL_PROD
  : import.meta.env.VITE_API_URL;

// Axios instance creation
export const makeRequest = axios.create({
  baseURL: apiUrl,
  headers: {
    // Additional headers can be added here
  },
});
```

### ProductsList
Here’s how you might use the useFetch hook in a component to fetch products:
```javascript
import { useEffect, useState } from "react";
import ProductCard from "../CrossApp/ProductCard.jsx";
import useFetch from "../../../hooks/useFetch.js";
import filterstring from "../../helpers/filter.js";
import Pages from "./Pages.jsx";
import { useLocation } from "react-router-dom";


const ProductsList = ({ catId, selectedFilter }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const location = useLocation();


  useEffect(() => {
    const searchParams = new URLSearchParams(location.search);
    const pageParam = searchParams.get("page");

    if (pageParam) {
      setCurrentPage(parseInt(pageParam));
    }
  }, [location.search, currentPage]);

  const itemsPerPage = 7;
  const filterQuery = encodeURI(filterstring(selectedFilter));
  const pagination = `pagination[page]=${currentPage}&pagination[pageSize]=${itemsPerPage}&`;
  const categoryFilter = `&filters[categories][id][$eq]=${catId}`;

  const { data, loading, error, meta } = useFetch(
    `/products?` + pagination + filterQuery + categoryFilter + "&populate=*"
  );

  if (loading || !data) return <>Loading….</>;
  if (error) return <>Error</>;
  return (
    <>
      <div className="productsList flex justify-start flex-wrap">
        <>
          {data?.map((item) => (
            <ProductCard item={item} key={item.id} />
          ))}
        </>
      </div>
      <div className=" flex justify-center w-full mt-9 text-lg">
        <Pages currentPage={currentPage} maxPage={meta.pagination.pageCount} />
      </div>
    </>
  );
};

export default ProductsList;

```
This example demonstrates how the useFetch hook can be utilized in a React component to fetch and display a list of products, handling loading states and errors gracefully.

#### How it works
- **useEffect Hook:** Automatically invokes the fetchData function whenever the url parameter changes. This design ensures that data fetching logic is encapsulated within the hook and is executed reactively based on dependency changes.
- **Error Handling:** The hook sets an error state if the fetch operation fails, allowing components using this hook to respond appropriately to API errors.
- **Loading State:** It manages a loading state that indicates whether the data is being fetched, which is useful for rendering loading indicators in the UI.
- **Data and Meta States:** These states store the actual data returned from the API and any metadata associated with it, such as pagination data from Strapi.