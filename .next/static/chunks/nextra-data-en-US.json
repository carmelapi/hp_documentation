{"/development/designSystem/color":{"title":"Importance of Color in Design Systems","data":{"":"Colors are essential in design systems, serving both aesthetic and functional purposes. Defining a color palette within a design system enables consistent branding, improves usability, and streamlines development.\nIncorporating colors into the code of a design system offers several advantages:\nConsistency: Centralized color definitions ensure a consistent look and feel across all digital products.\nEfficiency: Developers can easily reference and reuse color variables, speeding up development and reducing errors.\nScalability: As the project scales, having a predefined color scheme helps maintain design integrity without repetitive work.\nFor future developers, a well-documented color system within a design system is crucial as it:\nFacilitates Quick Integration: Developers can immediately understand and apply the design principles.\nMinimizes Errors: Predefined colors prevent discrepancies in UI components.\nEnhances Collaboration: A common language around color usage helps team members from different disciplines collaborate effectively.","comprehensive-color-scheme-table#Comprehensive Color Scheme Table":"Below is the detailed table of the color scheme from the provided PDF, including the shades for Coral, Spindle, Storm Dust, text, and background colors:\nCategory\t50\t100\t200\t300\t400\t500\t600\t700\t800\t900\t950\tSpecial\tCoral\t#fff5ed\t#ffe8d5\t#fecdaa\t#fda974\tPrimary: #fb874f\t#f85717\t#ea3c0c\t#c22a0c\t#9a2312\t#7c2012\t#430d07\t\tSpindle\t#f2f7fc\t#e2ecf7\tSecondary: #bcd4ec\t#a9c9e7\t#81add9\t#6392ce\t#4f79c1\t#4567b0\t#3d5590\t#354873\t#242e47\t\tStorm Dust\t#f5f6f6\t#e6e7e7\t#d0d1d1\t#afb1b1\t#878989\t#6c6e6e\tNeutral: #616363\t#4e4f50\t#444546\t#3c3d3d\t#262626\t\tText Colors\t\t\t\t\t\t\t\t\t\t\t\tDark: #0e2843\tBackground Colors\t\t\t\t\t\t\t\t\t\t\t\tLight: #F9F4F2\t\nThis table outlines the colors used in your project, ensuring a uniform visual style is maintained. The 'Special' column includes colors designated for specific purposes like text and background.","example#Example":"","how-we-implement-it-in-our-code#How we implement it in our code":"If you’d like to completely replace the default colors with your own custom colors, add your colors directly under the theme.colors section of your configuration file (`tailwind.config.js\n):\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\"],\n  theme: {\n    theme: {},\n    extend: {\n      colors: {\n        coral: {\n          400: \"#FB874F\",\n        },\n        spindle: {\n          50: \"#F2F7FC\",\n          100: \"#E2ECF7\",\n          200: \"#BCD4EC\",\n          700: \"#4567b0\",\n          800: \"#3D5590\",\n          900: \"#354873\",\n          950: \"#242e47\",\n        },\n        stormDust: {\n          600: \"#616363\",\n        },\n        light: {\n          100: \"#FCFCFC\",\n          200: \"#FCF8F0\",\n        },\n      },\n    },\n  },\n  plugins: [],\n};"}},"/development/designSystem/components/breadcrumbs":{"title":"Breadcrumbs","data":{"":"We have integrated the Breadcrumbs component into our application to enhance user navigation. This component plays a crucial role by providing users with links back to previous pages or the home page, depending on their navigation path. It helps users understand their current location within the application and navigate effectively.\nWe have carefully crafted this component to ensure it is reusable and adaptable across various parts of our application. It allows for a consistent and intuitive navigation experience, helping our users understand their location and how to return to previously visited pages.","structure#Structure":"Our Breadcrumbs component is structured to dynamically display navigation paths based on user interaction. Here's how we've set it up:\nuseState: We initialize a state variable locationPath to store a segment of the current URL path.\nuseEffect, useState from \"react\": We use these hooks to manage the component's state and to handle side effects.\nHiOutlineChevronRight from \"react-icons/hi\": This icon serves as a visual separator between elements of the breadcrumb trail.\nuseLocation from \"react-router-dom\": This hook allows us to access the current location object which reflects where the application is at any given time.","logic#Logic":"Conditional Rendering: If prevLocation is an empty string, we render a link to the home page. Otherwise, we display prevLocation as a navigable link.\nIcons: We use the HiOutlineChevronRight icon as a delimiter between the segments of the breadcrumb trail.\nCurrent Path Display: The locationPath, extracted from the URL, is displayed and capitalized to enhance readability.","props#Props":"prevLocation: This prop is crucial for our component. It can either be an empty string or a specific path, influencing the content displayed as the previous link in our breadcrumb trail. This flexibility allows the Breadcrumbs component to adapt to different parts of our application, providing appropriate navigation links based on user interaction.\nimport { useEffect, useState } from \"react\";\nimport { HiOutlineChevronRight } from \"react-icons/hi\";\nimport { useLocation } from \"react-router-dom\";\nconst Breadcrumbs = ({ prevLocation }) => {\n  const location = useLocation();\n  const [locationPath, setLocationPath] = useState(\"\");\n  useEffect(() => {\n    setLocationPath(location.pathname.split(\"/\")[1]);\n  }, [location]);\n  return (\n    <div className=\"w-full py-10 sm:py-10 flex gap-3\">\n      <p className=\"text-sm font-normal text-spindle-900 capitalize flex items-center\">\n        <span>\n          {\" \"}\n          {prevLocation === \"\" ? (\n            <a className=\" hover:font-bold\" href=\"/\">\n              Home\n            </a>\n          ) : (\n            prevLocation\n          )}\n        </span>\n        <span className=\"px-1\">\n          <HiOutlineChevronRight />\n        </span>\n        <span className=\"capitalize font-semibold\">{locationPath}</span>\n      </p>\n    </div>\n  );\n};\nexport default Breadcrumbs;"}},"/development/test":{"title":"Importance of Testing with Jest","data":{"":"Testing is a critical part of software development that ensures code quality and reliability. Jest is a popular JavaScript testing framework that simplifies writing tests, providing clear syntax and powerful tools.\nJest makes it easy to write tests by automatically mocking dependencies and providing a rich set of features to handle asynchronous tests, test coverage, and snapshots. Here’s why incorporating Jest into our project is beneficial:\nFast and Safe Refactoring: Jest tests can act as a safety net, allowing developers to refactor code confidently.\nDocumentation: Tests serve as documentation for our code. They help developers understand what the code is supposed to do.\nQuality Assurance: With Jest, we can ensure that our application behaves as expected under various scenarios.\nFor developers inheriting the project, Jest tests provide:\nQuick Understanding: Tests help new developers understand the codebase quickly and how different parts of the application interact.\nEase of Adding Features: With existing tests, developers feel more comfortable adding new features as they can ensure their changes do not break existing functionality.\nPrevent Regression: Automated testing helps catch regressions early in the development process.","installing-jest#Installing Jest":"To start using Jest in ourproject, we first need to install it. Here’s how we can add Jest to our project:\nnpm install --save-dev jest\nAdd the following section to our package.json:\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\nIn our provided files, we have a function filterstring that constructs query strings based on filter objects. Here’s how Jest is used to test various scenarios:\nimport filterstring from \"./filter.js\";\nconst testobj1 = {\n  price: 500,\n};\ntest(\"Only price\", () => {\n  expect(filterstring(testobj1)).toBe(\"filters[Price][$lt]=500\");\n});\nconst testobj2 = {\n  location: \"Stockholm\",\n};\ntest(\"Only location\", () => {\n  expect(filterstring(testobj2)).toBe(\"filters[Location][$eq]=Stockholm\");\n});\nconst testobj3 = {\n  price: 300,\n  location: \"Stockholm\",\n  shippingOptions: \"Pick up yourself\",\n};\ntest(\"Price , shipping and location\", () => {\n  expect(filterstring(testobj3)).toBe(\n    \"filters[Price][$lt]=300&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself\"\n  );\n});\nconst testobj4 = {\n  price: 901,\n  location: \"Stockholm\",\n  shippingOptions: \"Pick up yourself\",\n  material: [\"Steel\"],\n};\ntest(\"Price, shipping, location and material\", () => {\n  expect(filterstring(testobj4)).toBe(\n    \"filters[Price][$lt]=901&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself&filters[$or][0][Material][$eq]=Steel\"\n  );\n});\nconst testobj5 = {\n  era: [\"C. 1880s New Renaissance\", \"E. 1900-1910s Art Nouveau\"],\n};\ntest(\"Two eras\", () => {\n  expect(filterstring(testobj5)).toBe(\n    \"filters[$or][0][Era][$eq]=C. 1880s New Renaissance&filters[$or][1][Era][$eq]=E. 1900-1910s Art Nouveau\"\n  );\n});\nconst testobj6 = {\n  condition: [\"Good condition\"],\n};\ntest(\"One condition\", () => {\n  expect(filterstring(testobj6)).toBe(\n    \"filters[$or][0][Condition][$eq]=Good condition\"\n  );\n});\nconst testobj7 = {\n  price: 200,\n  location: \"Eskilstuna\",\n  shippingOptions: \"Home delivery within 2-3 days\",\n  material: [\"Wood\"],\n  condition: [\"Needs renovation\"],\n};\ntest(\"Price, location, shipping, condition and material\", () => {\n  expect(filterstring(testobj7)).toBe(\n    \"filters[Price][$lt]=200&filters[Location][$eq]=Eskilstuna&filters[ShippingOptions][$eq]=Home delivery within 2-3 days&filters[$or][0][Material][$eq]=Wood&filters[$or][0][Condition][$eq]=Needs renovation\"\n  );\n});\nconst testobj8 = {\n  location: [\"Stockholm\", \"Eskilstuna\"],\n};\ntest(\"two locations\", () => {\n  expect(filterstring(testobj8)).toBe(\n    \"filters[Location][$eq]=Stockholm,Eskilstuna\"\n  );\n});\nconst testobj9 = {\n  price: 500,\n  location: \"Stockholm\",\n  shippingOptions: \"Pick up at store\",\n  material: [\"Wood\", \"Fiberglass\"],\n  era: [\"Allmoge\"],\n  condition: [\"Good condition\", \"Okey condition\"],\n};\ntest(\"Price, location, shippingOptions, material, era and condition\", () => {\n  expect(filterstring(testobj9)).toBe(\n    \"filters[Price][$lt]=500&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up at store&filters[$or][0][Material][$eq]=Wood&filters[$or][1][Material][$eq]=Fiberglass&filters[$or][0][Era][$eq]=Allmoge&filters[$or][0][Condition][$eq]=Good condition&filters[$or][1][Condition][$eq]=Okey condition\"\n  );\n});\nconst testobj10 = {\n  material: [\"Steel\", \"Wood\", \"Fiberglass\"],\n  era: [\n    \"1920s Swedish Grace, 20th-century Classicism\",\n    \"1940-1950s Modernism, Folkhem Architecture\",\n  ],\n};\ntest(\"Material, Era\", () => {\n  expect(filterstring(testobj10)).toBe(\n    \"filters[$or][0][Material][$eq]=Steel&filters[$or][1][Material][$eq]=Wood&filters[$or][2][Material][$eq]=Fiberglass&filters[$or][0][Era][$eq]=1920s Swedish Grace, 20th-century Classicism&filters[$or][1][Era][$eq]=1940-1950s Modernism, Folkhem Architecture\"\n  );\n});"}}}