{"/development/designSystem":{"title":"Introduction to the Design system","data":{"":"Welcome to our most comprehensive UI Kit, meticulously crafted using Tailwind CSS. This UI kit serves as a robust foundation for your design system, offering a versatile collection of style guidelines, component variants, website sections, responsive pages, and layouts. Our free version is a gesture of support to the community, aimed at empowering developers and designers to launch impressive projects swiftly.\nIn the realm of UI/UX design, a design system acts as the blueprint for product development, ensuring consistency and coherence across a product's user interface. Components, as reusable and standardized elements, play a pivotal role in these systems. They facilitate efficient design and development processes, maintain consistency, and ensure the scalability of digital products.","consistency#Consistency":"Components help maintain visual and functional consistency across an application. They ensure that common elements like buttons, inputs, and layouts behave uniformly, which enhances the user experience and reinforces brand identity.","efficiency#Efficiency":"With predefined components, designers and developers save time and resources. Components can be reused in various parts of an application or even across multiple projects, which accelerates the development process and reduces the likelihood of bugs.","scalability#Scalability":"Components make scaling design efforts more manageable. As new functionalities are needed, existing components can be extended or combined to create complex interfaces without starting from scratch.","future-proofing#Future Proofing":"For future developers, a well-documented design system with robust components makes the onboarding process much easier. It allows new team members to quickly understand the application’s architecture and contribute more effectively."}},"/development":{"title":"Introduction","data":{"":"This documentation is designed to guide developers through the setup and deployment of our web-based project. It serves as a comprehensive manual for constructing a robust development environment, integrating essential technologies, and deploying a fully functional application. Our aim is to ensure that every developer, regardless of their level of expertise, can follow the steps smoothly and understand the project's technical landscape.The documentation is divided into several key sections, each addressing a critical aspect of the development process:\nSystem Requirements:\nOutlines the hardware and software prerequisites needed to effectively work with the project.\nInstalling React and Libraries:\nProvides a detailed walkthrough for setting up the development environment, including the installation of React and other necessary libraries.\nAPI Configuration:\nDiscusses how to configure and utilize the API that interacts with our content management system for efficient data handling.\nDesign System:\nDescribes the design principles and visual assets that maintain the project's aesthetic consistency.\nComponents:\nDetails the reusable components built for this project, enhancing modularity and maintainability.\nDeployment:\nGuides through the final steps to deploy the application to a production environment, ensuring it is accessible and performs optimally.\nBy adhering to the outlined procedures, developers will ensure that the project is not only up to the technical standards but also aligned with our operational objectives. This documentation will help streamline the development process, minimize potential issues, and provide a clear path from setup to deployment."}},"/development/api":{"title":"Historical Parts API Documentation","data":{"base-url#Base URL":"https://historical-parts.onrender.com/api/products","authentication#Authentication":"No authentication required.","endpoints#Endpoints":"","pickup-only#Pickup only":"Description: Retrieves products available for pickup only.\nMethod: GET\nEndpoint: /api/products?filters[ShippingOptions][$eq]=Pick up yourself","two-conditions#Two conditions":"Description: Retrieves product sin good or okay condition.\nMethod: GET\nEndpoint: /api/products?filters[$or][0][Condition][$eq]=Good condition&filters[$or][1][Condition][$eq]=Okay condition?populate=*","materials#Materials":"Description: Retrieves products made of steel or aluminum priced below 600 and available for pickup in Stockholm.\nMethod: GET\nEndpoint: /api/products?filters[Price][$lt]=600&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself&filters[$or][0][Material][$eq]=Steel&filters[$or][1][Material][$eq]=Aluminum","less-than-600-wood-stockholm-and-pickup-only#Less than 600 wood Stockholm and pickup only":"Description: Retrieves products made of wood priced below 600 located in Stockholm and available for pickup only.\nMethod: GET\nEndpoint: /api/products?filters[Price][$lt]=901&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself&filters[$or][0][Material][$eq]=Wood","two-styles#Two styles":"Description: Retrieves products from the C. 1880s New Renaissance or E. 1900-1910s Art Nouveau styles.\nMethod: GET\nEndpoint: /api/products?filters[$or][0][Era][$eq]=C. 1880s New Renaissance&filters[$or][1][Era][$eq]=E. 1900-1910s Art Nouveau","price-less-than-500-three-styles#Price Less than 500 three styles":"Description: Retrieves products priced below 500 from three different styles: C. 1880s New Renaissance, E. 1900-1910s Art Nouveau, and I. 1940s-1950s Modernism Folkhem Architecture.\nMethod: GET\nEndpoint: /api/products?filters[Price][$lt]=500&filters[$or][0][Era][$eq]=C. 1880s New Renaissance&filters[$or][1][Era][$eq]=E. 1900-1910s Art Nouveau&filters[$or][2][Era][$eq]=I. 1940s-1950s Modernism Folkhem Architecture","price-less-than-300-in-stockholm-pickup-only#Price less than 300 in Stockholm Pickup only":"Description: Retrieves products priced below 300 located in Stockholm and available for pickup only.\nMethod: GET\nEndpoint: /api/products?filters[Price][$lt]=300&filters[Location][$eq]=Stockholm&filters[ShippingOptions][$eq]=Pick up yourself","price-less-than-500#Price less than 500":"Description: Retrieves products priced below 500.\nMethod: GET\nEndpoint: /api/products?filters[Price][$lt]=500","pickup-and-stockholm#Pickup and Stockholm":"Description: Retrieves products available for pickup in Stockholm.\nMethod: GET\nEndpoint: /api/products?filters[ShippingOptions][$eq]=Pick up yourself&filters[Location][$eq]=Stockholm","dropoff-and-linköping#Dropoff and Linköping":"Description: Retrieves products available for dropoff in Linköping.\nMethod: GET\nEndpoint: /api/products?filters[ShippingOptions][$eq]=Get a shipping price&filters[Location][$eq]=Linköping","pickup-and-stockholm-and-less-than-500#Pickup and Stockholm and less than 500":"Description: Retrieves products priced below 500 available for pickup in Stockholm.\nMethod: GET\nEndpoint: /api/products?filters[ShippingOptions][$eq]=Pick up yourself&filters[Location][$eq]=Stockholm&filters[Price][$lt]=500","headers#Headers":"User-Agent: insomnia/8.6.1","fetch#Fetch":"Here is how you might use React hooks to fetch data from our API, using Strapi as the backend.\nIn our project, we've implemented two essential utilities, useFetch and makeRequest, to streamline the process of fetching data from our Strapi-powered API. Below is an in-depth look at each utility, demonstrating how they are constructed and how they function within our React application.useFetch is a custom React hook that we've developed to simplify the process of fetching data from the API, handling loading states, errors, and the response data. This hook is designed to be reusable across different components within our application, promoting code reusability and cleaner component structures.\nimport { useEffect, useState } from \"react\";\nimport { makeRequest } from \"../makeRequest\";\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(false);\n  const [meta, setMeta] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const res = await makeRequest.get(url);\n        setData(res.data.data);\n        setMeta(res.data.meta);\n      } catch (err) {\n        setError(true);\n      }\n      setLoading(false);\n    };\n    fetchData();\n  }, [url]);\n  return { data, loading, error, meta };\n};\nexport default useFetch;","makerequestjs#makeRequest.js":"The makeRequest utility is a configured instance of axios, a popular HTTP client for making requests to APIs. We've set it up to dynamically choose the base URL depending on whether the environment is in production or development mode. This setup ensures that API requests are directed to the correct server without manual changes to the codebase when moving from development to production.\nimport axios from 'axios';\n// Environment-specific API URLs\nconst apiUrl = import.meta.env.PROD\n  ? import.meta.env.VITE_API_URL_PROD\n  : import.meta.env.VITE_API_URL;\n// Axios instance creation\nexport const makeRequest = axios.create({\n  baseURL: apiUrl,\n  headers: {\n    // Additional headers can be added here\n  },\n});","productslist#ProductsList":"Here’s how you might use the useFetch hook in a component to fetch products:\nimport { useEffect, useState } from \"react\";\nimport ProductCard from \"../CrossApp/ProductCard.jsx\";\nimport useFetch from \"../../../hooks/useFetch.js\";\nimport filterstring from \"../../helpers/filter.js\";\nimport Pages from \"./Pages.jsx\";\nimport { useLocation } from \"react-router-dom\";\nconst ProductsList = ({ catId, selectedFilter }) => {\n  const [currentPage, setCurrentPage] = useState(1);\n  const location = useLocation();\n  useEffect(() => {\n    const searchParams = new URLSearchParams(location.search);\n    const pageParam = searchParams.get(\"page\");\n    if (pageParam) {\n      setCurrentPage(parseInt(pageParam));\n    }\n  }, [location.search, currentPage]);\n  const itemsPerPage = 7;\n  const filterQuery = encodeURI(filterstring(selectedFilter));\n  const pagination = `pagination[page]=${currentPage}&pagination[pageSize]=${itemsPerPage}&`;\n  const categoryFilter = `&filters[categories][id][$eq]=${catId}`;\n  const { data, loading, error, meta } = useFetch(\n    `/products?` + pagination + filterQuery + categoryFilter + \"&populate=*\"\n  );\n  if (loading || !data) return <>Loading….</>;\n  if (error) return <>Error</>;\n  return (\n    <>\n      <div className=\"productsList flex justify-start flex-wrap\">\n        <>\n          {data?.map((item) => (\n            <ProductCard item={item} key={item.id} />\n          ))}\n        </>\n      </div>\n      <div className=\" flex justify-center w-full mt-9 text-lg\">\n        <Pages currentPage={currentPage} maxPage={meta.pagination.pageCount} />\n      </div>\n    </>\n  );\n};\nexport default ProductsList;\nThis example demonstrates how the useFetch hook can be utilized in a React component to fetch and display a list of products, handling loading states and errors gracefully.","how-it-works#How it works":"useEffect Hook: Automatically invokes the fetchData function whenever the url parameter changes. This design ensures that data fetching logic is encapsulated within the hook and is executed reactively based on dependency changes.\nError Handling: The hook sets an error state if the fetch operation fails, allowing components using this hook to respond appropriately to API errors.\nLoading State: It manages a loading state that indicates whether the data is being fetched, which is useful for rendering loading indicators in the UI.\nData and Meta States: These states store the actual data returned from the API and any metadata associated with it, such as pagination data from Strapi."}}}